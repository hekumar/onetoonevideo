<html>

<head>
  <title>Express</title>
  <link rel="stylesheet" href="/stylesheets/style.css">
  <script src="/javascripts/socket.io.js"></script>
  <link rel="stylesheet" href="//unpkg.com/carbon-components@9.90.0/css/carbon-components.min.css">
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>

<body>
  <h3>version V3</h3>
  <div class="container" id="app">
    <!-- <button @click="sendCall">Click me</button> -->
    <div v-if="caller">
      <button class="btn btn-primary" @click="receiveCall">Receive</button>
    </div>
    
      <ul>
        <li v-for="user in users"><button @click="sendCall(user)">Call {{ user }}</button></li>
      </ul>
    
    
    <div class="flexChild" id="camera-container">
      <div class="camera-box">
        <video id="received_video" autoplay></video>
        <video id="local_video" autoplay muted></video>
        <button id="hangup-button" @click="hangUpCall">
          Hang Up
        </button>
      </div>
    </div>

  </div>
  <script>
    const socket = io();
    
  </script>
  <script>
    var mediaConstraints = {
      audio: false, // We want an audio track
      video: true // ...and we want a video track
    }
    var myPeerConnection;
    function createPeerConnection() {
      myPeerConnection = new RTCPeerConnection({
        iceServers : app.$data.iceServers
      });

      myPeerConnection.onicecandidate = handleICECandidateEvent;
      myPeerConnection.ontrack = handleTrackEvent;
      myPeerConnection.onnegotiationneeded = handleNegotiationNeededEvent;
      myPeerConnection.onremovetrack = handleRemoveTrackEvent;
      myPeerConnection.oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
      myPeerConnection.onicegatheringstatechange = handleICEGatheringStateChangeEvent;
      myPeerConnection.onsignalingstatechange = handleSignalingStateChangeEvent;
      myPeerConnection.onconnectionstatechange = handleconnectionstatechange;
    }
    async function handleVideoOfferMsg(msg) {
      console.log(msg);
      var localStream = null;
      await axios.get("/icecandidate")
            .then(response => {
               console.log(response.data.v);
               ice = 
                  []
               
               response.data.v.iceServers.urls.forEach( value => {
                 ice.push({
                  'url': value,
                  'credential': response.data.v.iceServers.credential,
                  'username': response.data.v.iceServers.username
                 })
               })
               console.log(ice);

               app.$data.iceServers = ice
            })
      createPeerConnection();

      var desc = new RTCSessionDescription(msg.sdp);

      myPeerConnection.setRemoteDescription(desc).then(function () {
        return navigator.mediaDevices.getUserMedia(mediaConstraints);
      })
      .then(function(stream) {
        localStream = stream;
        document.getElementById("local_video").srcObject = localStream;

        localStream.getTracks().forEach(track => myPeerConnection.addTrack(track, localStream));
      })
      .then(function() {
        return myPeerConnection.createAnswer();
      })
      .then(function(answer) {
        return myPeerConnection.setLocalDescription(answer);
      })
      .then(function() {
        var msg = {
          name: socket.id,
          target: app.$data.targetUserName,
          type: "video-answer",
          sdp: myPeerConnection.localDescription
        };

        socket.emit('receiveCall', msg)
      })
      .catch(handleGetUserMediaError);
    }


    function handleNegotiationNeededEvent() {
      myPeerConnection.createOffer().then(function(offer) {
        return myPeerConnection.setLocalDescription(offer);
      })
      .then(function() {
        socket.emit('call', {
          name: socket.id,
          target: app.$data.targetUserName,
          type: "video-offer",
          sdp: myPeerConnection.localDescription
        });
      })
      .catch((s) => {
        console.log(s);
      });
    }
    function handleICECandidateEvent(event){
      if (event.candidate) {
      console.log(event);
      socket.emit('ice', {
        type: "new-ice-candidate",
        target: app.$data.targetUserName,
        candidate: event.candidate
      });
  }

    }
    function handleTrackEvent(event){
      document.getElementById("received_video").srcObject = event.streams[0];
      document.getElementById("hangup-button").disabled = false
    }
    function handleRemoveTrackEvent(){
      var stream = document.getElementById("received_video").srcObject;
      var trackList = stream.getTracks();
    
      if (trackList.length == 0) {
        closeVideoCall();
      }
    }
    function handleICEConnectionStateChangeEvent(){
      switch(myPeerConnection.iceConnectionState) {
        case "closed":
        case "failed":
        case "disconnected":
          closeVideoCall();
          break;
      }
    }
    function handleICEGatheringStateChangeEvent(){

    }
    function handleSignalingStateChangeEvent(){
      switch(myPeerConnection.signalingState) {
        case "closed":
          closeVideoCall();
          break;
      }
    }
    function handleNewICECandidateMsg(msg) {
      console.log()
      var candidate = new RTCIceCandidate(msg.candidate);

      myPeerConnection.addIceCandidate(candidate)
        .catch((reportError) => {
          console.log(reportError)
        });
    }
    

    function closeVideoCall() {
      var remoteVideo = document.getElementById("received_video");
      var localVideo = document.getElementById("local_video");

      if (myPeerConnection) {
        myPeerConnection.ontrack = null;
        myPeerConnection.onremovetrack = null;
        myPeerConnection.onremovestream = null;
        myPeerConnection.onicecandidate = null;
        myPeerConnection.oniceconnectionstatechange = null;
        myPeerConnection.onsignalingstatechange = null;
        myPeerConnection.onicegatheringstatechange = null;
        myPeerConnection.onnegotiationneeded = null;

        if (remoteVideo.srcObject) {
          remoteVideo.srcObject.getTracks().forEach(track => track.stop());
        }

        if (localVideo.srcObject) {
          localVideo.srcObject.getTracks().forEach(track => track.stop());
        }

        myPeerConnection.close();
        myPeerConnection = null;
      }

      remoteVideo.removeAttribute("src");
      remoteVideo.removeAttribute("srcObject");
      localVideo.removeAttribute("src");
      remoteVideo.removeAttribute("srcObject");

      document.getElementById("hangup-button").disabled = true;
      targetUsername = null;
    }

    function handleVideoAnswerMessage(msg) {
      
      var desc = new RTCSessionDescription(msg.sdp);
      
      myPeerConnection.setRemoteDescription(desc);
    }
    function handleGetUserMediaError(e) {
      switch(e.name) {
        case "NotFoundError":
          alert("Unable to open your call because no camera and/or microphone" +
                "were found.");
          break;
        case "SecurityError":
        case "PermissionDeniedError":
          // Do nothing; this is the same as the user canceling the call.
          break;
        default:
          alert("Error opening your camera and/or microphone: " + e.message);
          break;
      }

      closeVideoCall();
    }
    function handleconnectionstatechange(ev){
      switch(myPeerConnection.connectionState) {
        case "new":
        case "checking":
          console.log("Connecting...");
          break;
        case "connected":
          console.log("Online");
          break;
        case "disconnected":
          console.log("Disconnecting...");
          break;
        case "closed":
          console.log("Offline");
          break;
        case "failed":
          console.log("Error");
          break;
        default:
          console.log("Unknown");
          break;
      }
    }
    


  
    var app = new Vue({
    el: '#app',
    // declare the data for the component (An array that houses the results and a query that holds the current search string)
    data: {
        caller: '',
        videoOfferSdp: {},
        videoReceiveSdp: {},
        targetUserName: '',
        users: [],
        iceServers: {}
    },
    // declare methods in this Vue component. here only one method which performs the search is defined
    methods: {
        // make an axios request to the server with the current search query
        async sendCall(user){
          this.targetUserName = user;
          console.log('click')
          if (myPeerConnection) {
            alert("You can't start a call because you already have one open!");
          } else {
            await axios.get("/icecandidate")
            .then(response => {
               console.log(response.data.v);
               ice = 
                  []
               
               response.data.v.iceServers.urls.forEach( value => {
                 ice.push({
                  'url': value,
                  'credential': response.data.v.iceServers.credential,
                  'username': response.data.v.iceServers.username
                 })
               })
               console.log(ice);

               this.iceServers = ice
            })
            createPeerConnection();

            navigator.mediaDevices.getUserMedia(mediaConstraints)
            .then(function(localStream) {
              document.getElementById("local_video").srcObject = localStream;
              localStream.getTracks().forEach(track => myPeerConnection.addTrack(track, localStream));
            })
            .catch(handleGetUserMediaError);
          }
          // socket.emit('call', {calling: socket.id})
        },
        renderCall(s){
          console.log(s);
          this.caller  = s.name;
        },
        receiveCall(){
          console.log('rc');
          handleVideoOfferMsg(this.videoOfferSdp)
          // socket.emit('receiveCall', { callerId : this.caller})

        },
        hangUpCall(){
          closeVideoCall();
          socket.emit('hangup',{
            name: socket.id,
            target: this.targetUserName,
            type: "hang-up"
          });
        },
        getIceServer(){
          axios.get("/icecandidate")
            .then(response => {
               console.log(response.data.v);
               ice = 
                  []
               
               response.data.v.iceServers.urls.forEach( value => {
                 ice.push({
                  'url': value,
                  'credential': response.data.v.iceServers.credential,
                  'username': response.data.v.iceServers.username
                 })
               })
               console.log(ice);

               this.iceServers = ice
            })
        }
    },
    mounted: function () {
      // this.getIceServer();
      socket.on('calling', (s)=>{
        console.log(s);
        this.targetUserName = s.name;
        this.videoOfferSdp = s;
        this.renderCall(s)
      });
      socket.on('ack', (s)=>{
        console.log(s);
        handleVideoAnswerMessage(s);
        
        this.videoReceiveSdp = s;
      });
      socket.on('icereceive', (s)=>{
        console.log(s);
        handleNewICECandidateMsg(s);
      });
      socket.on('joined', (s) => {
        this.users.push(s.user);
      })
      socket.on('hangupReceive', (s) => {
        closeVideoCall();
      })


    },
    // declare Vue watchers
    watch: {
        // watch for change in the query string and recall the search method
        
    }
  })
  </script>

</body>

</html>
